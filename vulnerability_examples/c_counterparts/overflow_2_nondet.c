unsigned char _x, _y, sum;

/*
// 1. independent function --- GOTO matched, result matched
void independent_func()
{
  _x = 3;
  _x = _x - 1;
  _x = _x - 3;
  assert(_x < 5);
}
*/

/*
// 2. Function without return --- GOTO matched, result matched
void increment_x()
{
  _x = _x + 3;
}
*/

/*
// 3. Function with return --- result matched
unsigned char get_x()
{
  _x = 101;
  return _x;
}
*/

// 4. nondet() function
unsigned char nondet()
{
  unsigned char i;
  return i;
}

void func_overflow() {
  _y = 240;
  _y = 0;
  //_x = 100;
  //increment_x();
  //_x = get_x();
  unsigned char _z = nondet();
  //_z = nondet(); // is NOT shown in --compact-trace! has to be initialied above
  //__ESBMC_assume(_z < 0); // set assert(.) to be anything
  //assume(_z < 0);
  //__ESBMC_assume(_z != 16); // set assert(sum != 0);
  __ESBMC_assume(_z < 255);
  __ESBMC_assume(_z > 239);
  __ESBMC_assume(_z != 240); // 240 = 16 * 15;
  //__ESBMC_assume(_z % 16 != 0);
  sum = _y + _z;
  //__ESBMC_assert(sum >= 0 && sum <= 255, "range of uint8_t");
  assert(sum % 16 != 0);
  //assert(sum > 100);
}

int main() {
  return 0;
}

// Notes:
// In order to show satisfiability in --compact-trace, the following conditions must be met:
// 1. use local var decl instead of global var decl
// 2. use initialisation instead of declaration + assignment
//
// N.B. __ESBMC_assume(.) is better than assyme(.)
