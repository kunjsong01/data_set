// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.26;

contract MyContract {
    uint8 _x;
    uint8 _y;
    uint8 sum;

    /*
    // 1. independent function
    function independent_func() external {
      _x = 3;
      _x = _x - 1;
      _x = _x - 3;
      assert(_x < 5);
    }

    // 2. Function without return
    function increment_x() public {
      _x = _x + 3;
    }

    // 3. Function with return
    function get_x() public returns(uint8)
    {
      _x = 101;
      return _x;
    }
    */

    // 4. nondet
    function nondet() public pure returns(uint8)
    {
      uint8 i;
      return i;
    }

    // 5. support for __ESBMC_assume
    function __ESBMC_assume(bool) internal pure { }
    function __VERIFIER_assume(bool) internal pure { }

    function func_overflow() external {
      // Assignment: C
      _y = 0;
      uint8 _z = nondet();
      sum = _y + _z;

      // Additional constraints here: C
      // 220 < z < 255
      // {240, 224}
      __ESBMC_assume(_z < 255);
      __VERIFIER_assume(_z > 220);
      //__ESBMC_assume(_z != 240); // 240 == 16 * 15
      __VERIFIER_assume(_z != 224); // 224 == 16 * 14

      // Property: P
      assert(sum % 16 != 0);
    }
}

/*
C  = [
       y=0             /\
       z=nondet()      /\
       sum = y+z       /\
       sum1 = sum % 16 /\
       _z != 240       /\
       _z != 224
     ]

P = [ sum1 != 0 ]
~P = [ sum1 == 0 ]

Find a counterexample that satisfies C /\ ~P

satisfiable?

*/

/*
  __ESBMC_assume(_z < 255);
  __ESBMC_assume(_z > 220);
  __ESBMC_assume(_z != 240); // 240 = 16 * 15;
  __ESBMC_assume(_z != 224); // 224 = 16 * 14;
  assert(sum % 16 != 0);
*/
